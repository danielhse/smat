import os
import numpy as np
import scipy as sp

# mtx_header = '''
# %%MatrixMarket matrix coordinate real general
# %-------------------------------------------------------------------------------
# % Reordered using Paolo's method
# %-------------------------------------------------------------------------------
# '''


def coo_matrix2mtx(sparse_matrix, mtx_path):
    """
    Convert a sparse matrix in COO format as as scipy.sparse object to .mtx format.
    Mtx is just a standard EL (edgelist) format with additional header metadata.
    All we need to do is add the header and save the rest as a .mtx file.
    """
    mtx_lines = []
    M,N = sparse_matrix.shape
    lines = list(zip(sparse_matrix.row, sparse_matrix.col, sparse_matrix.data))
    # Add the header
    mtx_lines.append(f'%%MatrixMarket matrix coordinate real general\n% Generated by el2mtx\n{M} {N} {len(lines)}')
    # Convert the 0-based indexing to 1-based indexing
    for line in lines:
        mtx_lines.append(
            ' '.join([str(x)
                 for x in line])
        )
        # if there are no edge values (only two values per line), add a 1
        if len(line) == 2:
            mtx_lines[-1] += ' 1'
        # mtx_lines.append(str(int(line.split()[0]) + 1) + ' ' + str(int(line.split()[1]) + 1) + ' ' + line.split()[2])
    
    # Save the .mtx file
    with open(mtx_path, 'w') as f:
        f.write('\n'.join(mtx_lines))


def el2mtx(el_path, mtx_path):
    """
    Convert a sparse matrix in COO format (edgelist) to .mtx format.
    Mtx is just a standard EL (edgelist) format with additional header metadata.
    All we need to do is add the header and save the rest as a .mtx file.
    But! We also need to convert the 0-based indexing to 1-based indexing.
    """
    mtx_lines = []
    # Read the .el file
    with open(el_path, 'r') as f:
        lines = [l for l in f.readlines() if l.strip() != '' and l.strip()[0] != '%']

    if len(lines) == 0:
        return
    # get number of nodes (matrix dimensions). M is the max among the first two elements of each line,
    # N is the max among the second two elements of each line
    edgelist = [list(map(int, line.split()[:2])) for line in lines]
    M = max([edge[0] for edge in edgelist]) + 1
    N = max([edge[1] for edge in edgelist]) + 1
    # Add the header
    mtx_lines.append(f'%%MatrixMarket matrix coordinate real general\n% Generated by el2mtx\n{M} {N} {len(lines)}')
    # Convert the 0-based indexing to 1-based indexing
    for line in lines:
        mtx_lines.append(
            ' '.join([str(int(x) + 1 if x.isnumeric() else float(x) + 1)
                 for x in line.split()])
        )
        # if there are no edge values (only two values per line), add a 1
        if len(line.split()) == 2:
            mtx_lines[-1] += ' 1'
        # mtx_lines.append(str(int(line.split()[0]) + 1) + ' ' + str(int(line.split()[1]) + 1) + ' ' + line.split()[2])
    
    # Save the .mtx file
    with open(mtx_path, 'w') as f:
        f.write('\n'.join(mtx_lines))


def mtx2el(mtx_path, el_path):
    """
    Convert a sparse matrix in .mtx format to COO format (edgelist).
    Mtx is just a standard EL (edgelist) format with additional header metadata.
    All we need to do is remove the header and save the rest as a .el file.
    But! We also need to convert the 1-based indexing to 0-based indexing.
    """
    el_lines = []
    # Read the .mtx file
    with open(mtx_path, 'r') as f:
        lines = f.readlines()

    # Skip the header
    header_skipped = False
    for line in lines:
        if line.strip()[0] == '%':
            continue
        # Skip the header
        if not header_skipped:
            header_skipped = True
            continue
        # Convert the 1-based indexing to 0-based indexing
        el_lines.append(
            ' '.join([str(int(x) -1 if x.isnumeric() else float(x) - 1)
                 for x in line.split()])
        )
        # el_lines.append(str(int(line.split()[0]) - 1) + ' ' + str(int(line.split()[1]) - 1) + ' ' + line.split()[2])
    
    el_lines.sort(key=lambda x: (int(x.split()[0]), int(x.split()[1])))
    # Save the edgelist
    with open(el_path, 'w') as f:
        f.write('\n'.join(el_lines))

def mtx2el_all_from_directory(mtx_dir, el_dir):
    """
    Convert all .mtx files in a directory to .el files.
    """
    mtx_files = [f for f in os.listdir(mtx_dir) if f.endswith('.mtx')]
    for f in mtx_files:
        mtx2el(os.path.join(mtx_dir,f), os.path.join(el_dir, f.split('.')[0] + '.el'))


def el2mtx_reordered_all_from_directory(mtx_dir, el_dir):
    """
    Convert all .el files in a directory to .mtx files.
    """
    mtx_files = [f for f in os.listdir(mtx_dir) if f.endswith('reordered.el')]
    for f in mtx_files:
        el2mtx(os.path.join(mtx_dir,f), os.path.join(el_dir, f.split('.')[0] + '.mtx'))



def el2mtx_all_from_directory(mtx_dir, el_dir):
    """
    Convert all .el files in a directory to .mtx files.
    """
    mtx_files = [f for f in os.listdir(mtx_dir) if f.endswith('.el')]
    for f in mtx_files:
        el2mtx(os.path.join(mtx_dir,f), os.path.join(el_dir, f.split('.')[0] + '.mtx'))


def main():
    mtx_dir = os.path.join(os.path.dirname(__file__), "../test")
    el_dir = mtx_dir
    el2mtx_all_from_directory(mtx_dir, el_dir)


if __name__ == '__main__':
    main()

