import os
import subprocess
import sys
import scipy as sp
import numpy as np
import utils

TAU = 0.5  #0.1


def el2mtx(el_path, mtx_path):
    """
    Convert a sparse matrix in COO format (edgelist) to .mtx format.
    Mtx is just a standard EL (edgelist) format with additional header metadata.
    All we need to do is add the header and save the rest as a .mtx file.
    But! We also need to convert the 0-based indexing to 1-based indexing.
    """
    mtx_lines = []
    # Read the .el file
    with open(el_path, 'r') as f:
        lines = [l for l in f.readlines() if l.strip() != '' and l.strip()[0] != '%']

    if len(lines) == 0:
        return
    # get number of nodes (matrix dimensions). M is the max among the first two elements of each line,
    # N is the max among the second two elements of each line
    edgelist = [list(map(int, line.split()[:2])) for line in lines]
    M = max([edge[0] for edge in edgelist]) + 1
    N = max([edge[1] for edge in edgelist]) + 1
    # Add the header
    mtx_lines.append(f'%%MatrixMarket matrix coordinate real general\n% Generated by el2mtx\n{M} {N} {len(lines)}')
    # Convert the 0-based indexing to 1-based indexing
    for line in lines:
        mtx_lines.append(
            ' '.join([str(int(x) + 1 if x.isnumeric() else float(x) + 1)
                 for x in line.split()])
        )
        # if there are no edge values (only two values per line), add a 1
        if len(line.split()) == 2:
            mtx_lines[-1] += ' 1'
        # mtx_lines.append(str(int(line.split()[0]) + 1) + ' ' + str(int(line.split()[1]) + 1) + ' ' + line.split()[2])
    
    # Save the .mtx file
    with open(mtx_path, 'w') as f:
        f.write('\n'.join(mtx_lines))


def mtx2el(mtx_path, el_path):
    """
    Convert a sparse matrix in .mtx format to COO format (edgelist).
    Mtx is just a standard EL (edgelist) format with additional header metadata.
    All we need to do is remove the header and save the rest as a .el file.
    But! We also need to convert the 1-based indexing to 0-based indexing.
    """
    el_lines = []
    # Read the .mtx file
    with open(mtx_path, 'r') as f:
        lines = f.readlines()

    # Skip the header
    header_skipped = False
    for line in lines:
        if line.strip()[0] == '%':
            continue
        # Skip the header
        if not header_skipped:
            header_skipped = True
            continue
        # Convert the 1-based indexing to 0-based indexing
        el_lines.append(
            ' '.join([str(int(x) -1 if x.isnumeric() else float(x) - 1)
                 for x in line.split()])
        )
        # el_lines.append(str(int(line.split()[0]) - 1) + ' ' + str(int(line.split()[1]) - 1) + ' ' + line.split()[2])
    
    el_lines.sort(key=lambda x: (int(x.split()[0]), int(x.split()[1])))
    # Save the edgelist
    with open(el_path, 'w') as f:
        f.write('\n'.join(el_lines))


def transpose_el_matrix(el_path) -> str:
    """
    Read the sparse matrix in EL format, transpose it, and save it back to a new file.
    Transposing a matrix in the edgelist format requires only swaping (u,v) -> (v,u):
    edge source and destination.
    """
    transposed_el_path = el_path.split('.')[0] + '_transposed.el'

    # # Read the .el file
    with open(el_path, 'r') as f:
        lines = [l for l in f.readlines() if l.strip() != '' and l.strip()[0] != '%']

    if len(lines) == 0:
        return
    
    edgelist = [list(map(int, line.split()[:2])) for line in lines]
    swapped_edgelist = [list(map(int, line.split()[:2][::-1])) for line in lines]
    swapped_sorted_edgelist = sorted([list(map(int, line.split()[:2][::-1])) for line in lines])

    with open(transposed_el_path, 'w') as f:
        f.write('\n'.join([' '.join([str(x) for x in edge]) for edge in swapped_sorted_edgelist ]))

    return transposed_el_path


def reorder_using_paolo(filename: str, paolos_path: str, 
                          col_block_size: int = 16, 
                          row_block_size: int = 16, 
                          output_filename: str = None):
    """
    Reorder the matrix using Paolo's method.
    """
    # skip already reorderd files
    if "reordered" in filename or "reordered" in filename:
        return

    if output_filename is None:
        output_filename = filename.split('.')[0] + '_reordered.mtx'

    if filename.endswith('.mtx'):
        # we need to convert it to .el format first
        el_filename = filename.split('.')[0] + '.el'
        mtx2el(filename, el_filename)
    else:
        el_filename = filename

    el_reordered_filename = el_filename.split('.')[0] + '_reordered.el'
    
    # run Paolo's reorderer
    os.system(f"{paolos_path}/programs/general/Matrix_Blocking -f {el_filename} -a 5"\
                    f" -b {col_block_size} -B {row_block_size} -F 1 -t {TAU}")
    
    # convert the reorderd .el file to .mtx
    # check if file exists
    if os.path.exists(el_reordered_filename):
        el2mtx(el_reordered_filename, output_filename)
    else:
        a = 1



def reorder_cols_using_paolo(filename: str, paolos_path: str, 
                          col_block_size: int = 16, 
                          row_block_size: int = 16, 
                          output_filename: str = None):
    """
    Reorder the matrix using Paolo's method. The filename points to a matrix
    with already reordered rows. We need to load it, transpose it, and store it back.
    Then, we can use Paolo's method to permute the rows of transposed matrix,
    effectively permuting the columns of the original matrix.
    """
    if "transposed" in filename:
        return

    if output_filename is None:
        output_filename = filename.split('.')[0] + '_transposed_reordered.mtx'

    if filename.endswith('.mtx'):
        # we process only .el matrices
        return
        # # we need to convert it to .el format first
        # el_filename = filename.split('.')[0] + '.el'
        # mtx2el(filename, el_filename)
    else:
        el_filename = filename

    el_filename_tansposed = transpose_el_matrix(el_filename)
    el_reordered_filename = el_filename.split('.')[0] + '_transposed_reordered.el'
    
    # run Paolo's reorderer
    print(f"{paolos_path}/programs/general/Matrix_Blocking -f {el_filename_tansposed} -a 5"\
                    f" -b {col_block_size} -B {row_block_size} -F 1 -t {TAU}")
    os.system(f"{paolos_path}/programs/general/Matrix_Blocking -f {el_filename_tansposed} -a 5"\
                    f" -b {col_block_size} -B {row_block_size} -F 1 -t {TAU}")
    
    # convert the reorderd .el file to .mtx
    # check if file exists
    if os.path.exists(el_reordered_filename):
        el2mtx(el_reordered_filename, output_filename)
    else:
        a = 1


def reorder_all_in_dir(mtx_dir: str, paolos_path: str, 
                         block_size_X: int = 16, 
                         block_size_Y: int = 16, 
                         output_dir: str = None):
    """
    Reorder all .mtx files in a directory using Paolo's method.
    """

    mtx_files = [f for f in os.listdir(mtx_dir) if f.endswith('.mtx') or f.endswith('.el')]
    for f in mtx_files:
        # check if the file is already reordered
        # if "reordered" in f:
        #     continue
        # reordered_filename = f.split('.')[0] + '_reordered.mtx'
        # if reordered_filename in mtx_files:
        #     continue
        if f.endswith("mtx"):
            utils.analyze_sparse_matrix(os.path.join(mtx_dir, f), block_size_X, block_size_Y)
        reorder_using_paolo(os.path.join(mtx_dir, f), paolos_path, block_size_X, block_size_Y, output_dir)


def reorder_cols_all_in_dir(mtx_dir: str, paolos_path: str, 
                         block_size_X: int = 16, 
                         block_size_Y: int = 16, 
                         output_dir: str = None):
    """
    Reorder all .mtx files in a directory using Paolo's method.
    """

    mtx_files = [f for f in os.listdir(mtx_dir) if f.endswith('.mtx') or f.endswith('.el')]
    for f in mtx_files:
        # do column permutation only for matrices with already permuted rows
        if not "reordered" in f:
            continue
        reorder_cols_using_paolo(os.path.join(mtx_dir, f), paolos_path, block_size_X, block_size_Y, output_dir)


if __name__ == "__main__":
    # check if we passed the paths by the command line arguments
    n = len(sys.argv)
    if n < 3:    
        path = "<path>/src/matrices/suitesparse"
        paolos_path = "<path>/preprocess"
    else:
        path = sys.argv[1]
        paolos_path = sys.argv[2]


    row_block_size = 16
    col_block_size = 8
    # row permutation
    reorder_all_in_dir(path, paolos_path, col_block_size, row_block_size)
    # transpose and column permutation
    reorder_cols_all_in_dir(path, paolos_path, col_block_size, row_block_size)
